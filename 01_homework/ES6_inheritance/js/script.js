//Наследование - способность объектов наследовать свойства и методы от других классов
//Внутри наследования используются прототипы

class Task {
    constructor(title){
        this.title = title;
        this.done = false;
        console.log('Task creation');
    }
}

//SubTask - класс, который представляет из себя подзадачу
//Для того, чтобы указать, что SubTask является подклассом Task, используется ключевое слово extends
//extends = расширяет
//После названия подкласса ставим пробел, и пишем extends, и далее название класса, которое мы расширяем
//Это все, что нужно, для того, чтобы определить наследование между двумя классами

class SubTask extends Task {
    constructor(title) {
        super(title);
        console.log('Subtask creation');
    }
}

//После классов, создаем объекты

let task = new Task('JavaScript learning');
let subtask = new SubTask('ES6 inheritance learning');

console.log(task);
console.log(subtask);

//Используя оператор instanceof проверим, является ли объект subtask представителем обоих классов

console.log(subtask instanceof Task);
console.log(subtask instanceof SubTask);

//Тот факт, что мы видиим д ва сообщения 'Task creation' в консоли означают, что SabTask, не имея конструктора
//использует конструктор родителя, то есть, если у подкласса нет конструктора,
//то он будет всегда использовать родительский конструктор
//И сообщения true в консоли озночают, что subtask является представителем класса SubTask, это итак что очевидно
//и subtask, также является представителем класса Task, потому что SubTask является подклассом класса Task


//Классы могут иметь свойства. Создадим свойства title, done
//Конструктор может принимать параметры, которые далее могут быть использованы для создания свойств
//при созданиии объектов укажем заголовок задачи
//Заметье, мы инициализируем свойства в конструкторе у класса Task,
//но при этом в SubTask мы отправляем заголовок 'ES6 inheritance learning'
//и пока конструктора у класса SubTask нет

//Если у подкласса нет конструктора, то он воспользуется конструктором родительского класса
//Но это не значит, что мы не можем определить классу SubTask свой конструктор
//Давайте это сделаем
//Ошибка
//Это происходит потому, что если подклассу мы указваем конструктор, то и этот конструтор должен вызвать
//конструтор родительского класса, мы можем это сделать используя ключевое слово - super
//super - вызовет конструтор родительского класса

//У SubTask title = undefind.
// Это происходит потому, что конструктор родительского класса ожидает title в качестве параметра
//Но в данном случае мы его не отправляем, для этого в конструк торе мы укажеи title
//так как при созданиии нового объекта мы отправляем 'ES6 inheritance learning'
//в качестве аргументов для super мы тоже отправляем title
//Теперь у SubTask title = 'ES6 inheritance learning'

//Для того, чтобы убедиться, что SubTask действительно использует свой констуктор
//Выведем в консоль сообщение похожее на сообщение родительского класса
//console.log('Subtask creation');

//в консоли три сообщения: первое сообщение 'Task creation' выводится при создании задачи Task,
//вот здесь let task = new Task('JavaScript learning');
//при создании подзадачи let subtask = new SubTask('ES6 inheritance learning');
//мы попадаем в констуктор, дальше мы вызываем констуртор родительского класса
//здесь выводится второе сообщение 'Task creation'
//Дальше мы позвращаемя к конструтору SubTask и выводится третье сообщение 'Subtask creation'
//Именоо поэтому мы видим три сообещения


/*

class Task2 {
}

class SubTask2 extends Task2 {
    constructor(title) {
        console.log('Subtask2 creation');
    }
}


let subtask2 = new SubTask2('ES6 inheritance learning');
console.log(subtask2);


 */

//Давайте посмотрим, что будет, если мы конструтор родительского класса как-будто удалим
//и вызов super тоже удалим, и создание task, и вывод в консоль task
//посмотрим сможет ли subtask2 правильно инициализироваться
//мы видем ошибку "this is not defined"
//это озночает, что если мы указываем для подкласса конструктор,
//этот конструктор должен вызывать конструктор родительского класса
//и этим вызовом является ключевое слово - super, должен быть первой строчкой,
//до того, как мы приступим к присваиванию свойств

class Task3 {
    constructor(title){
        this._title = title;
        this.done = false;
        console.log('Task3 creation');
        Task3.count += 1
    }

    get title(){
        return this._title;
    }

    set title(value){
        this._title = value;
    }

    static getDefaultTitle() {
        return 'TASK3'
    }

    complete(){
        this.done = true;
        console.log('Task3 ' + this.title + ' creation');
    }
}

Task3.count = 0;

class SubTask3 extends Task3 {
    constructor(title, parent) {
        super(title);
        this.parent = parent;
        console.log('SubTask3 creation');
    }
    complete() {
        //this.done = true; строка 170
        super.complete();
        console.log('SubTask3 ' + this.title + ' creation');
    }
}

let task3 = new Task3('JavaScript learning');
let subtask3 = new SubTask3('ES6 inheritance learning', 'Task3');

console.log(SubTask3.getDefaultTitle()); //это статический метод, который мы определили для класса Task3
console.log(SubTask3.count); //это статическое свойство у класса Task3

task3.complete();
subtask3.complete();


console.log(task3);
console.log(subtask3);


//присвоим классу SubTask свойство parent, в которой мы укажем родительскую задачу
//для этого в качестве параметра для SubTask мы укажем parent
// и при создании объекта в качестве второго аргумента укажем task3

//помимо наследования свойства, классы могут наследовать и методы (поведение)
//давайте добавим классу Task метод complete, который будет использовать, чтобы завершить задачу
//и в теле метода мы укажем в свойство done значениие true
//и в консоли выведем сообщениие, о том что задача с заголовком title выполнена
//для этого воспользуемся шаблонной строкой
//теперь после того, как мы создаем объекты -> завершаем задачу (false -> true) и также завершим подзадачу
//то есть у объекта subtask тоже есть метод complete(), хотя в классе SubTask мы его не указывали
//это значит что SubTask унаследовал метод complete() (он ему доступен)

//таким же способом мы можем унаследовать свойтсво get/set/статичекские свойства, то есть все члены класса
//но что делать, если нас не устраивает родиетельский метод,
//допустим мы хотим его полностью поменять или немного изменить, тогда мы можем его перезаписать
//для этого в подклассе мы объявляем метод с таким же названием, как у родительского
//в теле, которого мы можем сделать всё что угодно
//так же отметим, что задача выполнена
// и так же в консоли выведем сообщение console.log('Task3 ' + this.title + ' creation');
//изменив Task3 на SubTask3, теперь в консоли мы видиим SubTask3 вместо Task3
//это озночает, что SubTask теперь использует свой метод complete(), а не родительский

//но заметье, что нам пришлось указать this.done в двух местах, у родительского класса и у подкласса
//конечно мы повторили лишь одну строчку, но тем не менее в настоящем классе методы выполняют чуть больше работы
//и чтобы не нарушать принцип D.R.Y = Don't Repaet Yourself (Не повторяйся)
//в унаследованном методе мы можем вызвать метод родительского класса, а потом как-либо его дополнить
//для этого this.done мы удалим
//и используя ключевое слово super, далее ставим точку и выбираем метод родительского класса complete()
//таким образом, как только вызовется метод complete() у объекта subtask
//мы предпримем родительский класс, пометим done = true,
//далее выведем сообщение "Task3 ES6 inheritance learning creation"
//после чего мы перепрыгнем обратно в метод complete() класса SubTask3
//и выведем сообщениие "SubTask3 ES6 inheritance learning creation"
//мы перезаписали родительский метод и в перезаписанном методе мы использовали метод родительского класса

//Для полной картины добавим классу  Task3 getter и setter для свойства title, и статические свойства и метод

//начнем с геттера и сеттера
//для начала в названии title добавим нижнее подчеркивание
//после конструктора пишем get title() {}, а в теле методы мы просто вернем this._title;
//и set title() {}, который примет параметр value, и присвоим this._title = value;

//далее создадим статический метод getDefaultTitle, который просто вернет заголовок задачи по умолчанию
//будет называться 'TASK3'
//и после класса Task3 добавим статическое свойтсво, которое будет содержать в себе общее количество созданных задач
//инициализируем его со значением 0
//и при создании задачи добавим свойство count и единицу


//Далее посмотрим, как класс SubTask3 унаследовал эти свойтсва и методы
//Выведем значение вызова SubTask.getDefaultTitle(), также вызовем SubTask.count
//и get и set мы увидим в консоли

//в консоли мы видим 'TASK3' - это вызов статического метода у SubTask3.getDefaultTitle()
//видим цифру 2 - это статическое свойство SubTask3.count
//и если посмотрим на класс SubTask, то увидим, что у него есть некое свойство title, помимо _title

//Таким образом мы унаследовали свойства, методы, статические свойства, статические методы, геттеры и сеттеры

