//Наследование - способность объектов наследовать свойства и методы от других классов
//Внутри наследования используются прототипы

class Task {
    constructor(title){
        this.title = title;
        this.done = false;
        console.log('Task creation');
    }
}

//SubTask - класс, который представляет из себя подзадачу
//Для того, чтобы указать, что SubTask является подклассом Task, используется ключевое слово extends
//extends = расширяет
//После названия подкласса ставим пробел, и пишем extends, и далее название класса, которое мы расширяем
//Это все, что нужно, для того, чтобы определить наследование между двумя классами

class SubTask extends Task {
    constructor() {
        super();
    }
}

//После классов, создаем объекты

let task = new Task('JavaScript learning');
let subtask = new SubTask('ES6 inheritance learning');

console.log(task);
console.log(subtask);

//Используя оператор instanceof проверим, является ли объект subtask представителем обоих классов

console.log(subtask instanceof Task);
console.log(subtask instanceof SubTask);

//Тот факт, что мы видиим д ва сообщения 'Task creation' в консоли означают, что SabTask, не имея конструктора
//использует конструктор родителя, то есть, если у подкласса нет конструктора,
//то он будет всегда использовать родительский конструктор
//И сообщения true в консоли озночают, что subtask является представителем класса SubTask, это итак что очевидно
//и subtask, также является представителем класса Task, потому что SubTask является подклассом класса Task


//Классы могут иметь свойства. Создадим свойства title, done
//Конструктор может принимать параметры, которые далее могут быть использованы для создания свойств
//при созданиии объектов укажем заголовок задачи
//Заметье, мы инициализируем свойства в конструкторе у класса Task,
//но при этом в SubTask мы отправляем заголовок 'ES6 inheritance learning'
//и пока конструктора у класса SubTask нет

//Если у подкласса нет конструктора, то он воспользуется конструктором родительского класса
//Но это не значит, что мы не можем определить классу SubTask свой конструктор
//Давайте это сделаем
//Ошибка
//Это происходит потому, что если подклассу мы указваем конструктор, то и этот конструтор должен вызвать
//конструтор родительского класса, мы можем это сделать используя ключевое слово - super
//super - вызовет конструтор родительского класса

//У SubTask title = undefind.
// Это происходит потому, что конструктор родительского класса ожтдает title в качестве параметра





